//
//  This file is part of a five file concatenation of the CwlViews_iOS
//  framework with internal interfaces for source inclusion in projects instead
//  of library inclusion.
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2017 Matt Gallagher ( http://cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlUtilsConcat tool on 2018-03-17 06:51:19 +0000 from the following files:
//
//    SplitViewController.swift
//    NavigationController.swift
//    NavigationBar.swift
//    TextView.swift
//    BarButtonItem.swift
//    GestureRecognizer.swift
//    View.swift
//    TextField.swift
//    Button.swift
//

import UIKit

// MARK: ### CwlSplitViewController.swift ###

class SplitViewController: ConstructingBinder, SplitViewControllerInstance {
	typealias Instance = UISplitViewController
	typealias Inherited = ViewController
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var splitViewControllerInstance: Instance { return instance() }
	
	enum Binding: SplitViewControllerBinding {
		typealias Binder = SplitViewController
		static func splitViewControllerBinding(_ binding: Binding) -> Binding { return binding }
	  case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case primaryViewController(DynamicValue<ViewControllerInstance>)
		case secondaryViewController(DynamicValue<ViewControllerInstance>)
		case presentsWithGesture(DynamicValue<Bool>)
		case preferredDisplayMode(DynamicValue<UISplitViewControllerDisplayMode>)
		case preferredPrimaryColumnWidthFraction(DynamicValue<CGFloat>)
		case minimumPrimaryColumnWidth(DynamicValue<CGFloat>)
		case maximumPrimaryColumnWidth(DynamicValue<CGFloat>)
		case shouldShowSecondary(DynamicValue<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case displayModeButton(SignalInput<BarButtonItemInstance?>)
		case willChangeDisplayMode(SignalInput<UISplitViewControllerDisplayMode>)
		case dismissedSecondary(SignalInput<()>)

	  // 4. Delegate bindings require synchronous evaluation within the object's context.
		case targetDisplayModeForAction((UISplitViewController) -> UISplitViewControllerDisplayMode)
		case preferredInterfaceOrientation((UISplitViewController) -> UIInterfaceOrientation)
		case supportedInterfaceOrientations((UISplitViewController) -> UIInterfaceOrientationMask)
		case primaryViewControllerForCollapsing((UISplitViewController) -> UIViewController?)
		case collapseSecondary((UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool)
		case primaryViewControllerForExpanding((UISplitViewController) -> UIViewController?)
		case separateSecondary((UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?)
		case showPrimaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
		case showSecondaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = SplitViewController
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init(nibName: nil, bundle: nil) }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}

		var primary = Captured<ViewControllerInstance>()
		var secondary = Captured<ViewControllerInstance>()

		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .primaryViewController(let x): primary = x.capture()
			case .secondaryViewController(let x): secondary = x.capture()
			case .willChangeDisplayMode(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:willChangeTo:))
				delegate().addSelector(s).willChangeDisplayMode = x
			case .targetDisplayModeForAction(let x):
				let s = #selector(UISplitViewControllerDelegate.targetDisplayModeForAction(in:))
				delegate().addSelector(s).targetDisplayMode = x
			case .preferredInterfaceOrientation(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewControllerPreferredInterfaceOrientationForPresentation(_:))
				delegate().addSelector(s).preferredInterfaceOrientation = x
			case .supportedInterfaceOrientations(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewControllerSupportedInterfaceOrientations(_:))
				delegate().addSelector(s).supportedInterfaceOrientations = x
			case .primaryViewControllerForCollapsing(let x):
				let s = #selector(UISplitViewControllerDelegate.primaryViewController(forCollapsing:))
				delegate().addSelector(s).primaryViewControllerForCollapsing = x
			case .primaryViewControllerForExpanding(let x):
				let s = #selector(UISplitViewControllerDelegate.primaryViewController(forExpanding:))
				delegate().addSelector(s).primaryViewControllerForExpanding = x
			case .showPrimaryViewController(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:show:sender:))
				delegate().addSelector(s).showPrimaryViewController = x
			case .showSecondaryViewController(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:showDetail:sender:))
				delegate().addSelector(s).showSecondaryViewController = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			storage.secondaryViewController = secondary.initial()?.viewControllerInstance
			instance.viewControllers = [primary.initial()?.viewControllerInstance ?? UIViewController()]
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .primaryViewController: return primary.resume()?.apply(instance, storage) { i, s, v in i.show(v.viewControllerInstance, sender: nil) }
			case .secondaryViewController:
				return secondary.resume()?.apply(instance, storage) { i, s, v in
					let vc = v.viewControllerInstance
					s.secondaryViewController = vc
					i.showDetailViewController(vc, sender: nil)
				}
			case .presentsWithGesture(let x): return x.apply(instance, storage) { i, s, v in i.presentsWithGesture = v }
			case .preferredDisplayMode(let x): return x.apply(instance, storage) { i, s, v in i.preferredDisplayMode = v }
			case .preferredPrimaryColumnWidthFraction(let x): return x.apply(instance, storage) { i, s, v in i.preferredPrimaryColumnWidthFraction = v }
			case .minimumPrimaryColumnWidth(let x): return x.apply(instance, storage) { i, s, v in i.minimumPrimaryColumnWidth = v }
			case .maximumPrimaryColumnWidth(let x): return x.apply(instance, storage) { i, s, v in i.maximumPrimaryColumnWidth = v }
			case .displayModeButton(let x):
				storage.displayModeButton = x
				return nil
			case .dismissedSecondary(let x):
				storage.dismissedSecondary = x
				return nil
			case .shouldShowSecondary(let x):
				return x.apply(instance, storage) { i, s, v in
					if v == true && s.shouldShowSecondary == false, let svc = s.secondaryViewController {
						i.showDetailViewController(svc, sender: nil)
					}
					s.shouldShowSecondary = v
				}
			case .willChangeDisplayMode: return nil
			case .targetDisplayModeForAction: return nil
			case .preferredInterfaceOrientation: return nil
			case .supportedInterfaceOrientations: return nil
			case .primaryViewControllerForCollapsing: return nil
			case .collapseSecondary(let x):
				storage.collapseSecondary = x
				return nil
			case .primaryViewControllerForExpanding: return nil
			case .separateSecondary(let x):
				storage.separateSecondary = x
				return nil
			case .showPrimaryViewController: return nil
			case .showSecondaryViewController: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}

		mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Cancellable? {
			let cancellable = linkedPreparer.finalizeInstance(instance, storage: storage)
			if !instance.isCollapsed {
				storage.displayModeButton?.send(value: instance.displayModeButtonItem)
			}
			return cancellable
		}
	}

	class Storage: ViewController.Storage, UISplitViewControllerDelegate {
		var secondaryViewController: UIViewController? = nil
		var shouldShowSecondary: Bool = true
		var displayModeButton: SignalInput<BarButtonItemInstance?>?
		var dismissedSecondary: SignalInput<()>?
		
		override var inUse: Bool {
			return true
		}
		
		func collapsedController(_ controller: UINavigationController) {
			if let svc = secondaryViewController, svc === controller {
				dismissedSecondary?.send(value: ())
			}
		}

		override func viewWillAppear(controller: UIViewController, animated: Bool) {
			if let secondary = secondaryViewController, let splitViewController = controller as? UISplitViewController {
				splitViewController.viewControllers.append(secondary)
			}
			super.viewWillAppear(controller: controller, animated: animated)
		}
		
		var collapseSecondary: ((UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool)?
		func splitViewController(_ splitViewController: UISplitViewController, collapseSecondary secondaryViewController: UIViewController, onto primaryViewController: UIViewController) -> Bool {
			displayModeButton?.send(value: nil)
			return (collapseSecondary?(splitViewController, secondaryViewController, primaryViewController) ?? false) || !shouldShowSecondary
		}
		
		var separateSecondary: ((UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?)?
		func splitViewController(_ splitViewController: UISplitViewController, separateSecondaryFrom primaryViewController: UIViewController) -> UIViewController? {
			displayModeButton?.send(value: splitViewController.displayModeButtonItem)
			return separateSecondary?(splitViewController, primaryViewController)
		}
	}

	class Delegate: DynamicDelegate, UISplitViewControllerDelegate {
		required override init() {
			super.init()
		}
		
		var willChangeDisplayMode: SignalInput<UISplitViewControllerDisplayMode>?
		func splitViewController(_ svc: UISplitViewController, willChangeTo displayMode: UISplitViewControllerDisplayMode) {
			willChangeDisplayMode!.send(value: displayMode)
		}
		
		var targetDisplayMode: ((UISplitViewController) -> UISplitViewControllerDisplayMode)?
		func targetDisplayModeForAction(in svc: UISplitViewController) -> UISplitViewControllerDisplayMode {
			return targetDisplayMode!(svc)
		}
		
		var preferredInterfaceOrientation: ((UISplitViewController) -> UIInterfaceOrientation)?
		func splitViewControllerPreferredInterfaceOrientationForPresentation(_ splitViewController: UISplitViewController) -> UIInterfaceOrientation {
			return preferredInterfaceOrientation!(splitViewController)
		}
		
		var supportedInterfaceOrientations: ((UISplitViewController) -> UIInterfaceOrientationMask)?
		func splitViewControllerSupportedInterfaceOrientations(_ splitViewController: UISplitViewController) -> UIInterfaceOrientationMask {
			return supportedInterfaceOrientations!(splitViewController)
		}
		
		var primaryViewControllerForCollapsing: ((UISplitViewController) -> UIViewController?)?
		func primaryViewController(forCollapsing splitViewController: UISplitViewController) -> UIViewController? {
			return primaryViewControllerForCollapsing!(splitViewController)
		}
		
		var primaryViewControllerForExpanding: ((UISplitViewController) -> UIViewController?)?
		func primaryViewController(forExpanding splitViewController: UISplitViewController) -> UIViewController? {
			return primaryViewControllerForExpanding!(splitViewController)
		}
		
		var showPrimaryViewController: ((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)?
		func splitViewController(_ splitViewController: UISplitViewController, show vc: UIViewController, sender: Any?) -> Bool {
			return showPrimaryViewController!(splitViewController, vc, sender)
		}
		
		var showSecondaryViewController: ((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)?
		func splitViewController(_ splitViewController: UISplitViewController, showDetail vc: UIViewController, sender: Any?) -> Bool {
			return showSecondaryViewController!(splitViewController, vc, sender)
		}
	}
}

extension BindingName where Binding: SplitViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.$1(v)) }) }
	static var primaryViewController: BindingName<DynamicValue<ViewControllerInstance>, Binding> { return BindingName<DynamicValue<ViewControllerInstance>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewController(v)) }) }
	static var secondaryViewController: BindingName<DynamicValue<ViewControllerInstance>, Binding> { return BindingName<DynamicValue<ViewControllerInstance>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.secondaryViewController(v)) }) }
	static var presentsWithGesture: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.presentsWithGesture(v)) }) }
	static var preferredDisplayMode: BindingName<DynamicValue<UISplitViewControllerDisplayMode>, Binding> { return BindingName<DynamicValue<UISplitViewControllerDisplayMode>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredDisplayMode(v)) }) }
	static var preferredPrimaryColumnWidthFraction: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredPrimaryColumnWidthFraction(v)) }) }
	static var minimumPrimaryColumnWidth: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.minimumPrimaryColumnWidth(v)) }) }
	static var maximumPrimaryColumnWidth: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.maximumPrimaryColumnWidth(v)) }) }
	static var shouldShowSecondary: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.shouldShowSecondary(v)) }) }
	static var displayModeButton: BindingName<SignalInput<BarButtonItemInstance?>, Binding> { return BindingName<SignalInput<BarButtonItemInstance?>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.displayModeButton(v)) }) }
	static var willChangeDisplayMode: BindingName<SignalInput<UISplitViewControllerDisplayMode>, Binding> { return BindingName<SignalInput<UISplitViewControllerDisplayMode>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.willChangeDisplayMode(v)) }) }
	static var dismissedSecondary: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.dismissedSecondary(v)) }) }
	static var targetDisplayModeForAction: BindingName<(UISplitViewController) -> UISplitViewControllerDisplayMode, Binding> { return BindingName<(UISplitViewController) -> UISplitViewControllerDisplayMode, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.targetDisplayModeForAction(v)) }) }
	static var preferredInterfaceOrientation: BindingName<(UISplitViewController) -> UIInterfaceOrientation, Binding> { return BindingName<(UISplitViewController) -> UIInterfaceOrientation, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredInterfaceOrientation(v)) }) }
	static var supportedInterfaceOrientations: BindingName<(UISplitViewController) -> UIInterfaceOrientationMask, Binding> { return BindingName<(UISplitViewController) -> UIInterfaceOrientationMask, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.supportedInterfaceOrientations(v)) }) }
	static var primaryViewControllerForCollapsing: BindingName<(UISplitViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewControllerForCollapsing(v)) }) }
	static var collapseSecondary: BindingName<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool, Binding> { return BindingName<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.collapseSecondary(v)) }) }
	static var primaryViewControllerForExpanding: BindingName<(UISplitViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewControllerForExpanding(v)) }) }
	static var separateSecondary: BindingName<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.separateSecondary(v)) }) }
	static var showPrimaryViewController: BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding> { return BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.showPrimaryViewController(v)) }) }
	static var showSecondaryViewController: BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding> { return BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.showSecondaryViewController(v)) }) }
}

protocol SplitViewControllerInstance: ViewControllerInstance {
	var splitViewControllerInstance: SplitViewController.Instance { get }
}
extension SplitViewControllerInstance {
	var viewControllerInstance: ViewController.Instance { return splitViewControllerInstance }
}
extension SplitViewController.Instance: SplitViewControllerInstance {
	var splitViewControllerInstance: SplitViewController.Instance { return self }
}

protocol SplitViewControllerBinding: ViewControllerBinding {
	static func splitViewControllerBinding(_ binding: SplitViewController.Binding) -> Self
}

extension SplitViewControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return Self.splitViewControllerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlNavigationController.swift ###

class NavigationController: ConstructingBinder, NavigationControllerInstance {
	typealias Instance = UINavigationController
	typealias Inherited = ViewController
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var navigationControllerInstance: Instance { return instance() }
	
	enum Binding: NavigationControllerBinding {
		typealias Binder = NavigationController
		static func navigationControllerBinding(_ binding: Binding) -> Binding { return binding }
	  case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationBar(StaticValue<NavigationBar>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case stack(DynamicValue<StackMutation<ViewControllerInstance>>)
		case supportedInterfaceOrientations(DynamicValue<UIInterfaceOrientationMask>)
		case preferredInterfaceOrientation(DynamicValue<UIInterfaceOrientation>)
		case isNavigationBarHidden(DynamicValue<SetOrAnimate<Bool>>)
		case isToolbarHidden(DynamicValue<SetOrAnimate<Bool>>)
		case hidesBarsOnTap(DynamicValue<Bool>)
		case hidesBarsOnSwipe(DynamicValue<Bool>)
		case hidesBarsWhenVerticallyCompact(DynamicValue<Bool>)
		case hidesBarsWhenKeyboardAppears(DynamicValue<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case poppedToCount(SignalInput<Int>)
		case willShow(SignalInput<(viewController: UIViewController, animated: Bool)>)
		case didShow(SignalInput<(viewController: UIViewController, animated: Bool)>)
		
	  // 4. Delegate bindings require synchronous evaluation within the object's context.
		case animationController((_ navigationController: UINavigationController, _ operation: UINavigationControllerOperation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?)
		case interactionController((_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = NavigationController
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage(popSignal: popSignal) }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init(nibName: nil, bundle: nil) }
		
		init() {
			self.init(delegateClass: NavigationControllerDelegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: NavigationControllerDelegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: NavigationControllerDelegate.Type
		var possibleDelegate: NavigationControllerDelegate? = nil
		mutating func delegate() -> NavigationControllerDelegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var popSignal: SignalInput<Int>? = nil
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .poppedToCount(let x): popSignal = x
			case .supportedInterfaceOrientations:
				delegate().addSelector(#selector(UINavigationControllerDelegate.navigationControllerSupportedInterfaceOrientations(_:)))
			case .preferredInterfaceOrientation:
				delegate().addSelector(#selector(UINavigationControllerDelegate.navigationControllerPreferredInterfaceOrientationForPresentation(_:)))
			case .animationController(let x):
				let s = #selector(UINavigationControllerDelegate.navigationController(_:animationControllerFor:from:to:))
				delegate().addSelector(s).animationController = x
			case .interactionController(let x):
				let s = #selector(UINavigationControllerDelegate.navigationController(_:interactionControllerFor:))
				delegate().addSelector(s).interactionController = x
			case .willShow:
				let s = #selector(UINavigationControllerDelegate.navigationController(_:willShow:animated:))
				delegate().addSelector(s)
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: UINavigationController, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			instance.delegate = storage
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .navigationBar(let x):
				x.value.applyBindings(to: instance.navigationBar)
				return nil
			case .stack(let x):
				return x.apply(instance, storage) { i, s, v in
					switch v {
					case .push(let e):
						s.expectedStackCount += 1
						i.pushViewController(e.viewControllerInstance, animated: true)
					case .pop:
						s.expectedStackCount -= 1
						i.popViewController(animated: true)
					case .popToCount(let c):
						s.expectedStackCount = c
						i.popToViewController(i.viewControllers[c - 1], animated: true)
					case .reload(let newStack):
						s.expectedStackCount = newStack.count
						i.setViewControllers(newStack.map { $0.viewControllerInstance }, animated: false)
					}
				}
			case .isNavigationBarHidden(let x): return x.apply(instance, storage) { i, s, v in i.setNavigationBarHidden(v.value, animated: v.isAnimated) }
			case .isToolbarHidden(let x): return x.apply(instance, storage) { i, s, v in i.setToolbarHidden(v.value, animated: v.isAnimated) }
			case .hidesBarsOnTap(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsOnTap = v }
			case .hidesBarsOnSwipe(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsOnSwipe = v }
			case .hidesBarsWhenVerticallyCompact(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsWhenVerticallyCompact = v }
			case .hidesBarsWhenKeyboardAppears(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsWhenKeyboardAppears = v }
			case .supportedInterfaceOrientations: return nil
			case .preferredInterfaceOrientation: return nil
			case .didShow(let x):
				storage.didShow = x
				return nil
			case .willShow: return nil
			case .animationController: return nil
			case .interactionController: return nil
			case .poppedToCount: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: ViewController.Storage, UINavigationControllerDelegate {
		var supportedInterfaceOrientations: UIInterfaceOrientationMask = .all
		var preferredInterfaceOrientation: UIInterfaceOrientation = .portrait
		var expectedStackCount: Int = 0
		let popSignal: SignalInput<Int>?
		weak var collapsedController: UINavigationController?
		
		override var inUse: Bool {
			return true
		}
		
		init(popSignal: SignalInput<Int>?) {
			self.popSignal = popSignal
			super.init()
		}
		
		var didShow: SignalInput<(viewController: UIViewController, animated: Bool)>?
		func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
			// Handle pop operations triggered by the back button
			if animated, navigationController.viewControllers.count < expectedStackCount, let ps = popSignal {
				ps.send(value: navigationController.viewControllers.count)
			}
			
			// Handle removal of collapsed split view details
			if animated, navigationController.viewControllers.count == expectedStackCount, let collapsed = collapsedController, let splitViewStorage = navigationController.splitViewController?.getBinderStorage(type: SplitViewController.Storage.self) {
				collapsedController = nil
				splitViewStorage.collapsedController(collapsed)
			}
			
			// Track when a collapsed split view is added
			if navigationController.viewControllers.count == expectedStackCount + 1, let collapsed = navigationController.viewControllers.last as? UINavigationController {
				collapsedController = collapsed
			}
			
			didShow?.send(value: (viewController: viewController, animated: animated))
		}
	}
}

class NavigationControllerDelegate: DynamicDelegate, UINavigationControllerDelegate {
	required override init() {
		super.init()
	}
	
	var willShow: ((UIViewController, Bool) -> ())?
	func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {
		return willShow!(viewController, animated)
	}
	
	var supportedInterfaceOrientations: (() -> UIInterfaceOrientationMask)?
	func navigationControllerSupportedInterfaceOrientations(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask {
		return supportedInterfaceOrientations!()
	}
	
	var preferredInterfaceOrientationForPresentation: (() -> UIInterfaceOrientation)?
	func navigationControllerPreferredInterfaceOrientationForPresentation(_ navigationController: UINavigationController) -> UIInterfaceOrientation {
		return preferredInterfaceOrientationForPresentation!()
	}
	
	var animationController: ((_ navigationController: UINavigationController, _ operation: UINavigationControllerOperation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?)?
	func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationControllerOperation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
		return animationController!(navigationController, operation, fromVC, toVC)
	}
	
	var interactionController: ((_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)?
	func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?
	{
		return interactionController!(navigationController, animationController)
	}
}

extension BindingName where Binding: NavigationControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.$1(v)) }) }
	static var navigationBar: BindingName<StaticValue<NavigationBar>, Binding> { return BindingName<StaticValue<NavigationBar>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.navigationBar(v)) }) }
	static var stack: BindingName<DynamicValue<StackMutation<ViewControllerInstance>>, Binding> { return BindingName<DynamicValue<StackMutation<ViewControllerInstance>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.stack(v)) }) }
	static var supportedInterfaceOrientations: BindingName<DynamicValue<UIInterfaceOrientationMask>, Binding> { return BindingName<DynamicValue<UIInterfaceOrientationMask>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.supportedInterfaceOrientations(v)) }) }
	static var preferredInterfaceOrientation: BindingName<DynamicValue<UIInterfaceOrientation>, Binding> { return BindingName<DynamicValue<UIInterfaceOrientation>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.preferredInterfaceOrientation(v)) }) }
	static var isNavigationBarHidden: BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.isNavigationBarHidden(v)) }) }
	static var isToolbarHidden: BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.isToolbarHidden(v)) }) }
	static var hidesBarsOnTap: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsOnTap(v)) }) }
	static var hidesBarsOnSwipe: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsOnSwipe(v)) }) }
	static var hidesBarsWhenVerticallyCompact: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsWhenVerticallyCompact(v)) }) }
	static var hidesBarsWhenKeyboardAppears: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsWhenKeyboardAppears(v)) }) }
	static var poppedToCount: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.poppedToCount(v)) }) }
	static var willShow: BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding> { return BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.willShow(v)) }) }
	static var didShow: BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding> { return BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.didShow(v)) }) }
	static var animationController: BindingName<(_ navigationController: UINavigationController, _ operation: UINavigationControllerOperation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding> { return BindingName<(_ navigationController: UINavigationController, _ operation: UINavigationControllerOperation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.animationController(v)) }) }
	static var interactionController: BindingName<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding> { return BindingName<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.interactionController(v)) }) }
}

protocol NavigationControllerInstance: ViewControllerInstance {
	var navigationControllerInstance: NavigationController.Instance { get }
}
extension NavigationControllerInstance {
	var viewControllerInstance: ViewController.Instance { return navigationControllerInstance }
}
extension NavigationController.Instance: NavigationControllerInstance {
	var navigationControllerInstance: NavigationController.Instance { return self }
}

protocol NavigationControllerBinding: ViewControllerBinding {
	static func navigationControllerBinding(_ binding: NavigationController.Binding) -> Self
}
extension NavigationControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return Self.navigationControllerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlNavigationBar.swift ###

class NavigationBar: ConstructingBinder, NavigationBarInstance {
	typealias Instance = UINavigationBar
	typealias Inherited = View
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var navigationBarInstance: Instance { return instance() }
	
	enum Binding: NavigationBarBinding {
		typealias Binder = NavigationBar
		static func navigationBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(DynamicValue<SetOrAnimate<[NavigationItemInstance]>>)
		case backIndicatorImage(DynamicValue<UIImage?>)
		case backIndicatorTransitionMaskImage(DynamicValue<UIImage?>)
		case barStyle(DynamicValue<UIBarStyle>)
		case barTintColor(DynamicValue<UIColor?>)
		case shadowImage(DynamicValue<UIImage?>)
		case tintColor(DynamicValue<UIColor?>)
		case isTranslucent(DynamicValue<Bool>)
		case titleTextAttributes(DynamicValue<[NSAttributedStringKey: Any]>)
		case titleVerticalPositionAdjustment(DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>)
		case backgroundImage(DynamicValue<ScopedValues<PositionAndMetrics, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case didPush(SignalInput<UINavigationItem>)
		case didPop(SignalInput<UINavigationItem>)
		
	  // 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldPush((UINavigationBar, UINavigationItem) -> Bool)
		case shouldPop((UINavigationBar, UINavigationItem) -> Bool)
		case position((UIBarPositioning) -> UIBarPosition)
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = NavigationBar
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldPush(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:shouldPush:))
				delegate().addSelector(s).shouldPush = x
			case .shouldPop(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:shouldPop:))
				delegate().addSelector(s).shouldPop = x
			case .position(let x):
				let s = #selector(UINavigationBarDelegate.position(for:))
				delegate().addSelector(s).position = x
			case .didPush(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:didPush:))
				delegate().addSelector(s).didPush = x
			case .didPop(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:didPop:))
				delegate().addSelector(s).didPop = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			// Don't steal the delegate from the navigation controller
			if possibleDelegate != nil {
				precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
				storage.dynamicDelegate = possibleDelegate
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .backgroundImage(let x):
				var previous: ScopedValues<PositionAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .titleVerticalPositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, CGFloat>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleVerticalPositionAdjustment(0, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleVerticalPositionAdjustment(c.1, for: c.0)
					}
				}
			case .items(let x): return x.apply(instance, storage) { i, s, v in i.setItems(v.value.map { $0.navigationItemInstance }, animated: v.isAnimated) }
			case .backIndicatorImage(let x): return x.apply(instance, storage) { i, s, v in i.backIndicatorImage = v }
			case .backIndicatorTransitionMaskImage(let x): return x.apply(instance, storage) { i, s, v in i.backIndicatorTransitionMaskImage = v }
			case .barStyle(let x): return x.apply(instance, storage) { i, s, v in i.barStyle = v }
			case .barTintColor(let x): return x.apply(instance, storage) { i, s, v in i.barTintColor = v }
			case .shadowImage(let x): return x.apply(instance, storage) { i, s, v in i.shadowImage = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .isTranslucent(let x): return x.apply(instance, storage) { i, s, v in i.isTranslucent = v }
			case .titleTextAttributes(let x):
				return x.apply(instance, storage) { i, s, v in
					i.titleTextAttributes = v
				}
			case .didPush: return nil
			case .didPop: return nil
			case .shouldPush: return nil
			case .shouldPop: return nil
			case .position: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: View.Storage, UINavigationBarDelegate {}

	class Delegate: DynamicDelegate, UINavigationBarDelegate {
		required override init() {
			super.init()
		}
		
		var shouldPop: ((_ navigationBar: UINavigationBar, _ item: UINavigationItem) -> Bool)?
		func navigationBar(_ navigationBar: UINavigationBar, shouldPop item: UINavigationItem) -> Bool {
			return shouldPop!(navigationBar, item)
		}
		
		var shouldPush: ((_ navigationBar: UINavigationBar, _ item: UINavigationItem) -> Bool)?
		func navigationBar(_ navigationBar: UINavigationBar, shouldPush item: UINavigationItem) -> Bool {
			return shouldPush!(navigationBar, item)
		}
		
		var didPop: SignalInput<UINavigationItem>?
		func navigationBar(_ navigationBar: UINavigationBar, didPop item: UINavigationItem) {
			didPop!.send(value: item)
		}
		
		var didPush: SignalInput<UINavigationItem>?
		func navigationBar(_ navigationBar: UINavigationBar, didPush item: UINavigationItem) {
			didPush!.send(value: item)
		}
		
		var position: ((UIBarPositioning) -> UIBarPosition)?
		func position(for bar: UIBarPositioning) -> UIBarPosition {
			return position!(bar)
		}
	}
}

extension BindingName where Binding: NavigationBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.$1(v)) }) }
	static var items: BindingName<DynamicValue<SetOrAnimate<[NavigationItemInstance]>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<[NavigationItemInstance]>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.items(v)) }) }
	static var backIndicatorImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backIndicatorImage(v)) }) }
	static var backIndicatorTransitionMaskImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backIndicatorTransitionMaskImage(v)) }) }
	static var barStyle: BindingName<DynamicValue<UIBarStyle>, Binding> { return BindingName<DynamicValue<UIBarStyle>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.barStyle(v)) }) }
	static var barTintColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.barTintColor(v)) }) }
	static var shadowImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shadowImage(v)) }) }
	static var tintColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.tintColor(v)) }) }
	static var isTranslucent: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.isTranslucent(v)) }) }
	static var titleTextAttributes: BindingName<DynamicValue<[NSAttributedStringKey: Any]>, Binding> { return BindingName<DynamicValue<[NSAttributedStringKey: Any]>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.titleTextAttributes(v)) }) }
	static var titleVerticalPositionAdjustment: BindingName<DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.titleVerticalPositionAdjustment(v)) }) }
	static var backgroundImage: BindingName<DynamicValue<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backgroundImage(v)) }) }
	static var didPush: BindingName<SignalInput<UINavigationItem>, Binding> { return BindingName<SignalInput<UINavigationItem>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.didPush(v)) }) }
	static var didPop: BindingName<SignalInput<UINavigationItem>, Binding> { return BindingName<SignalInput<UINavigationItem>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.didPop(v)) }) }
	static var shouldPush: BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding> { return BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shouldPush(v)) }) }
	static var shouldPop: BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding> { return BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shouldPop(v)) }) }
}

protocol NavigationBarInstance: ViewInstance {
	var navigationBarInstance: NavigationBar.Instance { get }
}
extension NavigationBarInstance {
	var viewInstance: View.Instance { return navigationBarInstance }
}
extension NavigationBar.Instance: NavigationBarInstance {
	var navigationBarInstance: NavigationBar.Instance { return self }
}

protocol NavigationBarBinding: ViewBinding {
	static func navigationBarBinding(_ binding: NavigationBar.Binding) -> Self
}
extension NavigationBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return Self.navigationBarBinding(.inheritedBinding(binding))
	}
}

struct PositionAndMetrics {
	let barPosition: UIBarPosition
	let barMetrics: UIBarMetrics
	init(position: UIBarPosition = .any, metrics: UIBarMetrics = .default) {
		self.barPosition = position
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == PositionAndMetrics {
	static func any(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .any, metrics: metrics))
	}
	static func bottom(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .bottom, metrics: metrics))
	}
	static func top(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .top, metrics: metrics))
	}
	static func topAttached(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .topAttached, metrics: metrics))
	}
}

// MARK: ### CwlTextView.swift ###

class TextView: ConstructingBinder, TextViewInstance {
	typealias Instance = UITextView
	typealias Inherited = ScrollView
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var textViewInstance: Instance { return instance() }
	
	enum Binding: TextViewBinding {
		typealias Binder = TextView
		static func textViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(StaticValue<TextInputTraits>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case text(DynamicValue<String>)
		case attributedText(DynamicValue<NSAttributedString>)
		case font(DynamicValue<UIFont?>)
		case textColor(DynamicValue<UIColor?>)
		case isEditable(DynamicValue<Bool>)
		case allowsEditingTextAttributes(DynamicValue<Bool>)
		case dataDetectorTypes(DynamicValue<UIDataDetectorTypes>)
		case textAlignment(DynamicValue<NSTextAlignment>)
		case typingAttributes(DynamicValue<[String: Any]>)
		case linkTextAttributes(DynamicValue<[String: Any]>)
		case textContainerInset(DynamicValue<UIEdgeInsets>)
		case selectedRange(DynamicValue<NSRange>)
		case clearsOnInsertion(DynamicValue<Bool>)
		case isSelectable(DynamicValue<Bool>)
		case inputView(DynamicValue<ViewInstance?>)
		case inputAccessoryView(DynamicValue<ViewInstance?>)
		
		// 2. Signal bindings are performed on the object after construction.
		case scrollRangeToVisible(Signal<NSRange>)
		
		//	3. Action bindings are triggered by the object after construction.
		case didBeginEditing(SignalInput<UITextView>)
		case didEndEditing(SignalInput<UITextView>)
		case didChange(SignalInput<UITextView>)
		case didChangeSelection(SignalInput<UITextView>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBeginEditing((UITextView) -> Bool)
		case shouldEndEditing((UITextView) -> Bool)
		case shouldChangeText((UITextView, NSRange, String) -> Bool)
		@available(iOS 10.0, *)
		case shouldInteractWithAttachment((UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)
		@available(iOS 10.0, *)
		case shouldInteractWithURL((UITextView, URL, NSRange, UITextItemInteraction) -> Bool)
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = TextView
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		// Actual delegate construction is handled by the scroll view preparer
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init(delegateClass: Delegate.Type) {
			linkedPreparer = Inherited.Preparer(delegateClass: delegateClass)
		}
		var possibleDelegate: Delegate? { return linkedPreparer.possibleDelegate as? Delegate }
		mutating func delegate() -> Delegate { return linkedPreparer.delegate() as! Delegate }
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldBeginEditing(let x):
				let s = #selector(UITextViewDelegate.textViewShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UITextViewDelegate.textViewShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .didBeginEditing(let x):
				let s = #selector(UITextViewDelegate.textViewDidBeginEditing(_:))
				delegate().addSelector(s).didBeginEditing = x
			case .didEndEditing(let x):
				let s = #selector(UITextViewDelegate.textViewDidEndEditing(_:))
				delegate().addSelector(s).didEndEditing = x
			case .shouldChangeText(let x):
				let s = #selector(UITextViewDelegate.textView(_:shouldChangeTextIn:replacementText:))
				delegate().addSelector(s).shouldChangeText = x
			case .didChange(let x):
				let s = #selector(UITextViewDelegate.textViewDidChange(_:))
				delegate().addSelector(s).didChange = x
			case .didChangeSelection(let x):
				let s = #selector(UITextViewDelegate.textViewDidChangeSelection(_:))
				delegate().addSelector(s).didChangeSelection = x
			case .shouldInteractWithAttachment(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)?)
					delegate().addSelector(s).shouldInteractWithAttachment = x
				}
			case .shouldInteractWithURL(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, URL, NSRange, UITextItemInteraction) -> Bool)?)
					delegate().addSelector(s).shouldInteractWithAttachment = x
				}
			case .inheritedBinding(let preceeding): linkedPreparer.prepareBinding(preceeding)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .textInputTraits(let x):
				return ArrayOfCancellables(x.value.bindings.lazy.flatMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .isEditable(let x): return x.apply(instance, storage) { i, s, v in i.isEditable = v }
			case .allowsEditingTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.allowsEditingTextAttributes = v }
			case .dataDetectorTypes(let x): return x.apply(instance, storage) { i, s, v in i.dataDetectorTypes = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .typingAttributes(let x): return x.apply(instance, storage) { i, s, v in i.typingAttributes = v }
			case .linkTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.linkTextAttributes = v }
			case .textContainerInset(let x): return x.apply(instance, storage) { i, s, v in i.textContainerInset = v }
			case .selectedRange(let x): return x.apply(instance, storage) { i, s, v in i.selectedRange = v }
			case .clearsOnInsertion(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnInsertion = v }
			case .isSelectable(let x): return x.apply(instance, storage) { i, s, v in i.isSelectable = v }
			case .inputView(let x): return x.apply(instance, storage) { i, s, v in i.inputView = v?.viewInstance }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v?.viewInstance }
			case .scrollRangeToVisible(let x): return x.apply(instance, storage) { i, s, v in i.scrollRangeToVisible(v) }
			case .shouldBeginEditing: return nil
			case .didBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .didEndEditing: return nil
			case .shouldChangeText: return nil
			case .didChange: return nil
			case .didChangeSelection: return nil
			case .shouldInteractWithAttachment: return nil
			case .shouldInteractWithURL: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	class Storage: ScrollView.Storage, UITextViewDelegate {}
	
	class Delegate: ScrollView.Delegate, UITextViewDelegate {
		required init() {
			super.init()
		}
		
		var shouldBeginEditing: ((UITextView) -> Bool)?
		func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
			return shouldBeginEditing!(textView)
		}
		
		var shouldEndEditing: ((UITextView) -> Bool)?
		func textViewShouldEndEditing(_ textView: UITextView) -> Bool {
			return shouldEndEditing!(textView)
		}
		
		var didBeginEditing: SignalInput<UITextView>?
		func textViewDidBeginEditing(_ textView: UITextView) {
			didBeginEditing!.send(value: textView)
		}
		
		var didEndEditing: SignalInput<UITextView>?
		func textViewDidEndEditing(_ textView: UITextView) {
			didEndEditing!.send(value: textView)
		}
		
		var shouldChangeText: ((UITextView, NSRange, String) -> Bool)?
		func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return shouldChangeText!(textView, range, text)
		}
		
		var didChange: SignalInput<UITextView>?
		func textViewDidChange(_ textView: UITextView) {
			didChange!.send(value: textView)
		}
		
		var didChangeSelection: SignalInput<UITextView>?
		func textViewDidChangeSelection(_ textView: UITextView) {
			didChangeSelection!.send(value: textView)
		}
		
		var shouldInteractWithAttachment: Any?
		@available(iOS 10.0, *)
		func textView(_ textView: UITextView, shouldInteractWith textAttachment: NSTextAttachment, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return (shouldInteractWithAttachment as! (UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)(textView, textAttachment, characterRange, interaction)
		}
		
		var shouldInteractWithURL: Any?
		@available(iOS 10.0, *)
		func textView(_ textView: UITextView, shouldInteractWith url: URL, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return (shouldInteractWithAttachment as! (UITextView, URL, NSRange, UITextItemInteraction) -> Bool)(textView, url, characterRange, interaction)
		}
	}
}

extension BindingName where Binding: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .textViewBinding(TextView.Binding.$1(v)) }) }
	static var textInputTraits: BindingName<StaticValue<TextInputTraits>, Binding> { return BindingName<StaticValue<TextInputTraits>, Binding>({ v in .textViewBinding(TextView.Binding.textInputTraits(v)) }) }
	static var text: BindingName<DynamicValue<String>, Binding> { return BindingName<DynamicValue<String>, Binding>({ v in .textViewBinding(TextView.Binding.text(v)) }) }
	static var attributedText: BindingName<DynamicValue<NSAttributedString>, Binding> { return BindingName<DynamicValue<NSAttributedString>, Binding>({ v in .textViewBinding(TextView.Binding.attributedText(v)) }) }
	static var font: BindingName<DynamicValue<UIFont?>, Binding> { return BindingName<DynamicValue<UIFont?>, Binding>({ v in .textViewBinding(TextView.Binding.font(v)) }) }
	static var textColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .textViewBinding(TextView.Binding.textColor(v)) }) }
	static var isEditable: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.isEditable(v)) }) }
	static var allowsEditingTextAttributes: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.allowsEditingTextAttributes(v)) }) }
	static var dataDetectorTypes: BindingName<DynamicValue<UIDataDetectorTypes>, Binding> { return BindingName<DynamicValue<UIDataDetectorTypes>, Binding>({ v in .textViewBinding(TextView.Binding.dataDetectorTypes(v)) }) }
	static var textAlignment: BindingName<DynamicValue<NSTextAlignment>, Binding> { return BindingName<DynamicValue<NSTextAlignment>, Binding>({ v in .textViewBinding(TextView.Binding.textAlignment(v)) }) }
	static var typingAttributes: BindingName<DynamicValue<[String: Any]>, Binding> { return BindingName<DynamicValue<[String: Any]>, Binding>({ v in .textViewBinding(TextView.Binding.typingAttributes(v)) }) }
	static var linkTextAttributes: BindingName<DynamicValue<[String: Any]>, Binding> { return BindingName<DynamicValue<[String: Any]>, Binding>({ v in .textViewBinding(TextView.Binding.linkTextAttributes(v)) }) }
	static var textContainerInset: BindingName<DynamicValue<UIEdgeInsets>, Binding> { return BindingName<DynamicValue<UIEdgeInsets>, Binding>({ v in .textViewBinding(TextView.Binding.textContainerInset(v)) }) }
	static var selectedRange: BindingName<DynamicValue<NSRange>, Binding> { return BindingName<DynamicValue<NSRange>, Binding>({ v in .textViewBinding(TextView.Binding.selectedRange(v)) }) }
	static var clearsOnInsertion: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.clearsOnInsertion(v)) }) }
	static var isSelectable: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.isSelectable(v)) }) }
	static var inputView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .textViewBinding(TextView.Binding.inputView(v)) }) }
	static var inputAccessoryView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .textViewBinding(TextView.Binding.inputAccessoryView(v)) }) }
	static var scrollRangeToVisible: BindingName<Signal<NSRange>, Binding> { return BindingName<Signal<NSRange>, Binding>({ v in .textViewBinding(TextView.Binding.scrollRangeToVisible(v)) }) }
	static var didBeginEditing: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didBeginEditing(v)) }) }
	static var didEndEditing: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didEndEditing(v)) }) }
	static var didChange: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didChange(v)) }) }
	static var didChangeSelection: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didChangeSelection(v)) }) }
	static var shouldBeginEditing: BindingName<(UITextView) -> Bool, Binding> { return BindingName<(UITextView) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldBeginEditing(v)) }) }
	static var shouldEndEditing: BindingName<(UITextView) -> Bool, Binding> { return BindingName<(UITextView) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldEndEditing(v)) }) }
	static var shouldChangeText: BindingName<(UITextView, NSRange, String) -> Bool, Binding> { return BindingName<(UITextView, NSRange, String) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldChangeText(v)) }) }
	@available(iOS 10.0, *)
	static var shouldInteractWithAttachment: BindingName<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool, Binding> { return BindingName<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldInteractWithAttachment(v)) }) }
	@available(iOS 10.0, *)
	static var shouldInteractWithURL: BindingName<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool, Binding> { return BindingName<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldInteractWithURL(v)) }) }
}

protocol TextViewInstance: ScrollViewInstance {
	var textViewInstance: TextView.Instance { get }
}
extension TextViewInstance {
	var scrollViewInstance: ScrollView.Instance { return textViewInstance }
}
extension TextView.Instance: TextViewInstance {
	var textViewInstance: TextView.Instance { return self }
}

protocol TextViewBinding: ScrollViewBinding {
	static func textViewBinding(_ binding: TextView.Binding) -> Self
}
extension TextViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return Self.textViewBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlBarButtonItem.swift ###

class BarButtonItem: ConstructingBinder, BarButtonItemInstance {
	typealias Instance = UIBarButtonItem
	typealias Inherited = BarItem
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var barButtonItemInstance: Instance { return instance() }
	
	enum Binding: BarButtonItemBinding {
		typealias Binder = BarButtonItem
		static func barButtonItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case barButtonSystemItem(StaticValue<UIBarButtonSystemItem>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case itemStyle(DynamicValue<UIBarButtonItemStyle>)
		case possibleTitles(DynamicValue<Set<String>?>)
		case width(DynamicValue<CGFloat>)
		case customView(DynamicValue<ViewInstance?>)
		case tintColor(DynamicValue<UIColor?>)
		case backgroundImage(DynamicValue<ScopedValues<StateStyleAndMetrics, UIImage?>>)
		case backButtonBackgroundImage(DynamicValue<ScopedValues<StateAndMetrics, UIImage?>>)
		case backButtonTitlePositionAdjustment(DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>)
		case backgroundVerticalPositionAdjustment(DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>)
		case titlePositionAdjustment(DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case action(TargetAction<()>)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = BarButtonItem
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance {
			let x: UIBarButtonItem
			if let si = systemItem {
				x = subclass.init(barButtonSystemItem: si, target: nil, action: nil)
			} else if case .some(.some(let cv)) = customViewInitial {
				x = subclass.init(customView: cv.viewInstance)
			} else if case .some(.some(let i)) = imageInitial {
				x = subclass.init(image: i, landscapeImagePhone: landscapeImagePhoneInitial ?? nil, style: itemStyleInitial ?? .plain, target: nil, action: nil)
			} else {
				x = subclass.init(title: titleInitial ?? nil, style: itemStyleInitial ?? .plain, target: nil, action: nil)
			}
			return x
		}
		
		var systemItem: UIBarButtonSystemItem?
		var customView = Captured<ViewInstance?>()
		var customViewInitial: ViewInstance?? = nil
		var itemStyle = Captured<UIBarButtonItemStyle>()
		var itemStyleInitial: UIBarButtonItemStyle? = nil
		var image = Captured<UIImage?>()
		var imageInitial: UIImage?? = nil
		var landscapeImagePhone = Captured<UIImage?>()
		var landscapeImagePhoneInitial: UIImage?? = nil
		var title = Captured<String>()
		var titleInitial: String? = nil
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .barButtonSystemItem(let x): systemItem = x.value
			case .customView(let x):
				customView = x.capture()
				customViewInitial = customView.initial()
			case .itemStyle(let x):
				itemStyle = x.capture()
				itemStyleInitial = itemStyle.initial()
			case .inheritedBinding(.image(let x)):
				image = x.capture()
				imageInitial = image.initial()
			case .inheritedBinding(.landscapeImagePhone(let x)):
				landscapeImagePhone = x.capture()
				landscapeImagePhoneInitial = landscapeImagePhone.initial()
			case .inheritedBinding(.title(let x)):
				title = x.capture()
				titleInitial = title.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .barButtonSystemItem: return nil
			case .backgroundImage(let x):
				var previous: ScopedValues<StateStyleAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.controlState, style: conditions.scope.itemStyle, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.controlState, style: conditions.scope.itemStyle, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .backButtonBackgroundImage(let x):
				var previous: ScopedValues<StateAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackButtonBackgroundImage(nil, for: conditions.scope.controlState, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackButtonBackgroundImage(image, for: conditions.scope.controlState, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .backButtonTitlePositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackButtonTitlePositionAdjustment(UIOffset.zero, for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackButtonTitlePositionAdjustment(c.value, for: c.scope)
					}
				}
			case .backgroundVerticalPositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, CGFloat>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackgroundVerticalPositionAdjustment(0, for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackgroundVerticalPositionAdjustment(c.value, for: c.scope)
					}
				}
			case .titlePositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitlePositionAdjustment(UIOffset.zero, for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitlePositionAdjustment(c.value, for: c.scope)
					}
				}
			case .itemStyle:
				return itemStyle.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.style = v } }
			case .possibleTitles(let x): return x.apply(instance, storage) { i, s, v in i.possibleTitles = v }
			case .width(let x): return x.apply(instance, storage) { i, s, v in i.width = v }
			case .customView:
				return customView.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.customView = v?.viewInstance } }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .action(let x): return x.apply(instance: instance, constructTarget: SignalActionTarget.init, processor: { sender in () })
				
			case .inheritedBinding(.image): return image.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.image = v } }
			case .inheritedBinding(.landscapeImagePhone): return landscapeImagePhone.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.landscapeImagePhone = v } }
			case .inheritedBinding(.title): return title.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.title = v } }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = BarItem.Storage
}

extension BindingName where Binding: BarButtonItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.$1(v)) }) }
	static var barButtonSystemItem: BindingName<StaticValue<UIBarButtonSystemItem>, Binding> { return BindingName<StaticValue<UIBarButtonSystemItem>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.barButtonSystemItem(v)) }) }
	static var itemStyle: BindingName<DynamicValue<UIBarButtonItemStyle>, Binding> { return BindingName<DynamicValue<UIBarButtonItemStyle>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.itemStyle(v)) }) }
	static var possibleTitles: BindingName<DynamicValue<Set<String>?>, Binding> { return BindingName<DynamicValue<Set<String>?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.possibleTitles(v)) }) }
	static var width: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.width(v)) }) }
	static var customView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.customView(v)) }) }
	static var tintColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.tintColor(v)) }) }
	static var backgroundImage: BindingName<DynamicValue<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backgroundImage(v)) }) }
	static var backButtonBackgroundImage: BindingName<DynamicValue<ScopedValues<StateAndMetrics, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<StateAndMetrics, UIImage?>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backButtonBackgroundImage(v)) }) }
	static var backButtonTitlePositionAdjustment: BindingName<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backButtonTitlePositionAdjustment(v)) }) }
	static var backgroundVerticalPositionAdjustment: BindingName<DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backgroundVerticalPositionAdjustment(v)) }) }
	static var titlePositionAdjustment: BindingName<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.titlePositionAdjustment(v)) }) }
	static var action: BindingName<TargetAction<()>, Binding> { return BindingName<TargetAction<()>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.action(v)) }) }
}

protocol BarButtonItemInstance: BarItemInstance {
	var barButtonItemInstance: BarButtonItem.Instance { get }
}
extension BarButtonItemInstance {
	var barItemInstance: BarItem.Instance { return barButtonItemInstance }
}
extension BarButtonItem.Instance: BarButtonItemInstance {
	var barButtonItemInstance: BarButtonItem.Instance { return self }
}

protocol BarButtonItemBinding: BarItemBinding {
	static func barButtonItemBinding(_ binding: BarButtonItem.Binding) -> Self
}
extension BarButtonItemBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return Self.barButtonItemBinding(.inheritedBinding(binding))
	}
}

extension UIBarButtonItem: TargetActionSender {}

struct StateStyleAndMetrics {
	let controlState: UIControlState
	let itemStyle: UIBarButtonItemStyle
	let barMetrics: UIBarMetrics
	init(state: UIControlState = .normal, style: UIBarButtonItemStyle = .plain, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.itemStyle = style
		self.barMetrics = metrics
	}
}

struct StateAndMetrics {
	let controlState: UIControlState
	let barMetrics: UIBarMetrics
	init(state: UIControlState = .normal, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == StateAndMetrics {
	static func normal(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .normal, metrics: metrics))
	}
	static func highlighted(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .highlighted, metrics: metrics))
	}
	static func disabled(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .disabled, metrics: metrics))
	}
	static func selected(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .selected, metrics: metrics))
	}
	@available(iOS 9.0, *)
	static func focused(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .focused, metrics: metrics))
	}
	static func application(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .application, metrics: metrics))
	}
	static func reserved(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == StateStyleAndMetrics {
	static func normal(style: UIBarButtonItemStyle = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .normal, metrics: metrics))
	}
	static func highlighted(style: UIBarButtonItemStyle = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .highlighted, metrics: metrics))
	}
	static func disabled(style: UIBarButtonItemStyle = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .disabled, metrics: metrics))
	}
	static func selected(style: UIBarButtonItemStyle = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .selected, metrics: metrics))
	}
	@available(iOS 9.0, *)
	static func focused(style: UIBarButtonItemStyle = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .focused, metrics: metrics))
	}
	static func application(style: UIBarButtonItemStyle = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .application, metrics: metrics))
	}
	static func reserved(style: UIBarButtonItemStyle = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == UIBarMetrics {
	static func `default`(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .default, value: value)
	}
	static func compact(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compact, value: value)
	}
	static func defaultPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .defaultPrompt, value: value)
	}
	static func compactPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compactPrompt, value: value)
	}
}


// MARK: ### CwlGestureRecognizer.swift ###

class GestureRecognizer: ConstructingBinder, GestureRecognizerInstance {
	typealias Instance = UIGestureRecognizer
	typealias Inherited = BaseBinder
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var gestureRecognizerInstance: Instance { return instance() }
	
	enum Binding: GestureRecognizerBinding {
		typealias Binder = GestureRecognizer
		static func gestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
	  case inheritedBinding(Inherited.Binding)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case cancelsTouchesInView(DynamicValue<Bool>)
		case delaysTouchesBegan(DynamicValue<Bool>)
		case delaysTouchesEnded(DynamicValue<Bool>)
		case allowedPressTypes(DynamicValue<[NSNumber]>)
		case allowedTouchTypes(DynamicValue<[NSNumber]>)
		@available(iOS 9.2, *) case requiresExclusiveTouchType(DynamicValue<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(SignalInput<()>)

	  // 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBegin((UIGestureRecognizer) -> Bool)
		case shouldReceiveTouch((UIGestureRecognizer, UITouch) -> Bool)
		case shouldRecognizeSimultanously((UIGestureRecognizer, UIGestureRecognizer) -> Bool)
		case shouldRequireFailure((UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool)
		case shouldBeRequiredToFail((UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool)
		case shouldReceivePress((UIGestureRecognizer, UIPress) -> Bool)
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = GestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldBegin(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizerShouldBegin(_:))
				delegate().addSelector(s).shouldBegin = x
			case .shouldReceiveTouch(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UITouch) -> Bool)?)
				delegate().addSelector(s).shouldReceiveTouch = x
			case .shouldRecognizeSimultanously(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:))
				delegate().addSelector(s).shouldRecognizeSimultanously = x
			case .shouldRequireFailure(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRequireFailureOf:))
				delegate().addSelector(s).shouldRequireFailure = x
			case .shouldBeRequiredToFail(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldBeRequiredToFailBy:))
				delegate().addSelector(s).shouldBeRequiredToFail = x
			case .shouldReceivePress(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UIPress) -> Bool)?)
				delegate().addSelector(s).shouldReceivePress = x
			case .inheritedBinding(let preceeding): linkedPreparer.prepareBinding(preceeding)
			default: break
			}
		}

		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .action(let x):
				let target = SignalActionTarget()
				instance.addTarget(target, action: target.selector)
				return target.signal.map { _ in () }.cancellableBind(to: x)
			case .cancelsTouchesInView(let x): return x.apply(instance, storage) { i, s, v in i.cancelsTouchesInView = v }
			case .delaysTouchesBegan(let x): return x.apply(instance, storage) { i, s, v in i.delaysTouchesBegan = v }
			case .delaysTouchesEnded(let x): return x.apply(instance, storage) { i, s, v in i.delaysTouchesEnded = v }
			case .allowedPressTypes(let x): return x.apply(instance, storage) { i, s, v in i.allowedPressTypes = v }
			case .allowedTouchTypes(let x): return x.apply(instance, storage) { i, s, v in i.allowedTouchTypes = v }
			case .requiresExclusiveTouchType(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(iOS 9.2, *) {
						i.requiresExclusiveTouchType = v
					}
				}
			case .shouldBegin: return nil
			case .shouldReceiveTouch: return nil
			case .shouldRecognizeSimultanously: return nil
			case .shouldRequireFailure: return nil
			case .shouldBeRequiredToFail: return nil
			case .shouldReceivePress: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: ObjectBinderStorage, UIGestureRecognizerDelegate {}

	class Delegate: DynamicDelegate, UIGestureRecognizerDelegate {
		required override init() {
			super.init()
		}
		
		var shouldBegin: ((UIGestureRecognizer) -> Bool)?
		func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldBegin!(gestureRecognizer)
		}
		
		var shouldReceiveTouch: ((UIGestureRecognizer, UITouch) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool {
			return shouldReceiveTouch!(gestureRecognizer, touch)
		}
		
		var shouldRecognizeSimultanously: ((UIGestureRecognizer, UIGestureRecognizer) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldRecognizeSimultanously!(gestureRecognizer, otherGestureRecognizer)
		}
		
		var shouldRequireFailure: ((UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldRequireFailure!(gestureRecognizer, otherGestureRecognizer)
		}
		
		var shouldBeRequiredToFail: ((UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldBeRequiredToFail!(gestureRecognizer, otherGestureRecognizer)
		}
		
		var shouldReceivePress: ((UIGestureRecognizer, UIPress) -> Bool)?
		func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress) -> Bool {
			return shouldReceivePress!(gestureRecognizer, press)
		}
	}
}

extension BindingName where Binding: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.$1(v)) }) }
	static var cancelsTouchesInView: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.cancelsTouchesInView(v)) }) }
	static var delaysTouchesBegan: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.delaysTouchesBegan(v)) }) }
	static var delaysTouchesEnded: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.delaysTouchesEnded(v)) }) }
	static var allowedPressTypes: BindingName<DynamicValue<[NSNumber]>, Binding> { return BindingName<DynamicValue<[NSNumber]>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.allowedPressTypes(v)) }) }
	static var allowedTouchTypes: BindingName<DynamicValue<[NSNumber]>, Binding> { return BindingName<DynamicValue<[NSNumber]>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.allowedTouchTypes(v)) }) }
	@available(iOS 9.2, *) static var requiresExclusiveTouchType: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.requiresExclusiveTouchType(v)) }) }
	static var action: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.action(v)) }) }
	static var shouldBegin: BindingName<(UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldBegin(v)) }) }
	static var shouldReceiveTouch: BindingName<(UIGestureRecognizer, UITouch) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UITouch) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldReceiveTouch(v)) }) }
	static var shouldRecognizeSimultanously: BindingName<(UIGestureRecognizer, UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldRecognizeSimultanously(v)) }) }
	static var shouldRequireFailure: BindingName<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldRequireFailure(v)) }) }
	static var shouldBeRequiredToFail: BindingName<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldBeRequiredToFail(v)) }) }
	static var shouldReceivePress: BindingName<(UIGestureRecognizer, UIPress) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UIPress) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldReceivePress(v)) }) }
}

protocol GestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { get }
}
extension GestureRecognizer.Instance: GestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { return self }
}

protocol GestureRecognizerBinding: BaseBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self
}

extension GestureRecognizerBinding {
	static func baseBinderBinding(_ binding: BaseBinder.Binding) -> Self {
		return Self.gestureRecognizerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlView.swift ###

class View: ConstructingBinder, ViewInstance {
	typealias Instance = UIView
	typealias Inherited = BaseBinder
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var viewInstance: Instance { return instance() }

	enum Binding: ViewBinding {
		typealias Binder = View
		static func viewBinding(_ binding: Binding) -> Binding { return binding }
	  case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case layer(StaticValue<BackingLayer>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case layout(DynamicValue<Layout>)
		case backgroundColor(DynamicValue<(UIColor?)>)
		case isHidden(DynamicValue<(Bool)>)
		case alpha(DynamicValue<(CGFloat)>)
		case isOpaque(DynamicValue<(Bool)>)
		case tintColor(DynamicValue<(UIColor)>)
		case tintAdjustmentMode(DynamicValue<(UIViewTintAdjustmentMode)>)
		case clipsToBounds(DynamicValue<(Bool)>)
		case clearsContextBeforeDrawing(DynamicValue<(Bool)>)
		case mask(DynamicValue<(ViewInstance?)>)
		case isUserInteractionEnabled(DynamicValue<(Bool)>)
		case isMultipleTouchEnabled(DynamicValue<(Bool)>)
		case isExclusiveTouch(DynamicValue<(Bool)>)
		case contentMode(DynamicValue<(UIViewContentMode)>)
		case horizontalContentCompressionResistancePriority(DynamicValue<UILayoutPriority>)
		case verticalContentCompressionResistancePriority(DynamicValue<UILayoutPriority>)
		case horizontalContentHuggingPriority(DynamicValue<UILayoutPriority>)
		case verticalContentHuggingPriority(DynamicValue<UILayoutPriority>)
		case semanticContentAttribute(DynamicValue<(UISemanticContentAttribute)>)
		case layoutMargins(DynamicValue<(UIEdgeInsets)>)
		case preservesSuperviewLayoutMargins(DynamicValue<(Bool)>)
		case gestureRecognizers(DynamicValue<[UIGestureRecognizer]>)
		case motionEffects(DynamicValue<([UIMotionEffect])>)
		case tag(DynamicValue<Int>)
		case restorationIdentifier(DynamicValue<String?>)

		// 2. Signal bindings are performed on the object after construction.
		case endEditing(Signal<Bool>)
		case becomeFirstResponder(Signal<()>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = View
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init(frame: CGRect.zero) }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .layer(let x):
				x.value.applyBindings(to: instance.layer)
				return nil
			case .layout(let x):
				return x.apply(instance, storage) { i, s, v in
					instance.applyLayout(v)
				}
			case .backgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.backgroundColor = v }
			case .isHidden(let x): return x.apply(instance, storage) { i, s, v in i.isHidden = v }
			case .alpha(let x): return x.apply(instance, storage) { i, s, v in i.alpha = v }
			case .isOpaque(let x): return x.apply(instance, storage) { i, s, v in i.isOpaque = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .tintAdjustmentMode(let x): return x.apply(instance, storage) { i, s, v in i.tintAdjustmentMode = v }
			case .clipsToBounds(let x): return x.apply(instance, storage) { i, s, v in i.clipsToBounds = v }
			case .clearsContextBeforeDrawing(let x): return x.apply(instance, storage) { i, s, v in i.clearsContextBeforeDrawing = v }
			case .mask(let x): return x.apply(instance, storage) { i, s, v in i.mask = v?.viewInstance }
			case .isUserInteractionEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isUserInteractionEnabled = v }
			case .isMultipleTouchEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isMultipleTouchEnabled = v }
			case .isExclusiveTouch(let x): return x.apply(instance, storage) { i, s, v in i.isExclusiveTouch = v }
			case .restorationIdentifier(let x): return x.apply(instance, storage) { i, s, v in i.restorationIdentifier = v }
			case .contentMode(let x): return x.apply(instance, storage) { i, s, v in i.contentMode = v }
			case .horizontalContentCompressionResistancePriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentCompressionResistancePriority(v, for: UILayoutConstraintAxis.horizontal) }
			case .verticalContentCompressionResistancePriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentCompressionResistancePriority(v, for: UILayoutConstraintAxis.vertical) }
			case .horizontalContentHuggingPriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentHuggingPriority(v, for: UILayoutConstraintAxis.horizontal) }
			case .verticalContentHuggingPriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentHuggingPriority(v, for: UILayoutConstraintAxis.vertical) }
			case .semanticContentAttribute(let x): return x.apply(instance, storage) { i, s, v in i.semanticContentAttribute = v }
			case .layoutMargins(let x): return x.apply(instance, storage) { i, s, v in i.layoutMargins = v }
			case .preservesSuperviewLayoutMargins(let x): return x.apply(instance, storage) { i, s, v in i.preservesSuperviewLayoutMargins = v }
			case .gestureRecognizers(let x): return x.apply(instance, storage) { i, s, v in i.gestureRecognizers = v }
			case .motionEffects(let x): return x.apply(instance, storage) { i, s, v in i.motionEffects = v }
			case .tag(let x): return x.apply(instance, storage) { i, s, v in i.tag = v }
			case .endEditing(let x): return x.apply(instance, storage) { i, s, v in i.endEditing(v) }
			case .becomeFirstResponder(let x): return x.apply(instance, storage) { i, s, v in i.becomeFirstResponder() }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .viewBinding(View.Binding.$1(v)) }) }
	static var layer: BindingName<StaticValue<BackingLayer>, Binding> { return BindingName<StaticValue<BackingLayer>, Binding>({ v in .viewBinding(View.Binding.layer(v)) }) }
	static var layout: BindingName<DynamicValue<Layout>, Binding> { return BindingName<DynamicValue<Layout>, Binding>({ v in .viewBinding(View.Binding.layout(v)) }) }
	static var backgroundColor: BindingName<DynamicValue<(UIColor?)>, Binding> { return BindingName<DynamicValue<(UIColor?)>, Binding>({ v in .viewBinding(View.Binding.backgroundColor(v)) }) }
	static var isHidden: BindingName<DynamicValue<(Bool)>, Binding> { return BindingName<DynamicValue<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isHidden(v)) }) }
	static var alpha: BindingName<DynamicValue<(CGFloat)>, Binding> { return BindingName<DynamicValue<(CGFloat)>, Binding>({ v in .viewBinding(View.Binding.alpha(v)) }) }
	static var isOpaque: BindingName<DynamicValue<(Bool)>, Binding> { return BindingName<DynamicValue<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isOpaque(v)) }) }
	static var tintColor: BindingName<DynamicValue<(UIColor)>, Binding> { return BindingName<DynamicValue<(UIColor)>, Binding>({ v in .viewBinding(View.Binding.tintColor(v)) }) }
	static var tintAdjustmentMode: BindingName<DynamicValue<(UIViewTintAdjustmentMode)>, Binding> { return BindingName<DynamicValue<(UIViewTintAdjustmentMode)>, Binding>({ v in .viewBinding(View.Binding.tintAdjustmentMode(v)) }) }
	static var clipsToBounds: BindingName<DynamicValue<(Bool)>, Binding> { return BindingName<DynamicValue<(Bool)>, Binding>({ v in .viewBinding(View.Binding.clipsToBounds(v)) }) }
	static var clearsContextBeforeDrawing: BindingName<DynamicValue<(Bool)>, Binding> { return BindingName<DynamicValue<(Bool)>, Binding>({ v in .viewBinding(View.Binding.clearsContextBeforeDrawing(v)) }) }
	static var mask: BindingName<DynamicValue<(ViewInstance?)>, Binding> { return BindingName<DynamicValue<(ViewInstance?)>, Binding>({ v in .viewBinding(View.Binding.mask(v)) }) }
	static var isUserInteractionEnabled: BindingName<DynamicValue<(Bool)>, Binding> { return BindingName<DynamicValue<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isUserInteractionEnabled(v)) }) }
	static var isMultipleTouchEnabled: BindingName<DynamicValue<(Bool)>, Binding> { return BindingName<DynamicValue<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isMultipleTouchEnabled(v)) }) }
	static var isExclusiveTouch: BindingName<DynamicValue<(Bool)>, Binding> { return BindingName<DynamicValue<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isExclusiveTouch(v)) }) }
	static var contentMode: BindingName<DynamicValue<(UIViewContentMode)>, Binding> { return BindingName<DynamicValue<(UIViewContentMode)>, Binding>({ v in .viewBinding(View.Binding.contentMode(v)) }) }
	static var horizontalContentCompressionResistancePriority: BindingName<DynamicValue<UILayoutPriority>, Binding> { return BindingName<DynamicValue<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.horizontalContentCompressionResistancePriority(v)) }) }
	static var verticalContentCompressionResistancePriority: BindingName<DynamicValue<UILayoutPriority>, Binding> { return BindingName<DynamicValue<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.verticalContentCompressionResistancePriority(v)) }) }
	static var horizontalContentHuggingPriority: BindingName<DynamicValue<UILayoutPriority>, Binding> { return BindingName<DynamicValue<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.horizontalContentHuggingPriority(v)) }) }
	static var verticalContentHuggingPriority: BindingName<DynamicValue<UILayoutPriority>, Binding> { return BindingName<DynamicValue<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.verticalContentHuggingPriority(v)) }) }
	static var semanticContentAttribute: BindingName<DynamicValue<(UISemanticContentAttribute)>, Binding> { return BindingName<DynamicValue<(UISemanticContentAttribute)>, Binding>({ v in .viewBinding(View.Binding.semanticContentAttribute(v)) }) }
	static var layoutMargins: BindingName<DynamicValue<(UIEdgeInsets)>, Binding> { return BindingName<DynamicValue<(UIEdgeInsets)>, Binding>({ v in .viewBinding(View.Binding.layoutMargins(v)) }) }
	static var preservesSuperviewLayoutMargins: BindingName<DynamicValue<(Bool)>, Binding> { return BindingName<DynamicValue<(Bool)>, Binding>({ v in .viewBinding(View.Binding.preservesSuperviewLayoutMargins(v)) }) }
	static var gestureRecognizers: BindingName<DynamicValue<[UIGestureRecognizer]>, Binding> { return BindingName<DynamicValue<[UIGestureRecognizer]>, Binding>({ v in .viewBinding(View.Binding.gestureRecognizers(v)) }) }
	static var motionEffects: BindingName<DynamicValue<([UIMotionEffect])>, Binding> { return BindingName<DynamicValue<([UIMotionEffect])>, Binding>({ v in .viewBinding(View.Binding.motionEffects(v)) }) }
	static var tag: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .viewBinding(View.Binding.tag(v)) }) }
	static var restorationIdentifier: BindingName<DynamicValue<String?>, Binding> { return BindingName<DynamicValue<String?>, Binding>({ v in .viewBinding(View.Binding.restorationIdentifier(v)) }) }
	static var endEditing: BindingName<Signal<Bool>, Binding> { return BindingName<Signal<Bool>, Binding>({ v in .viewBinding(View.Binding.endEditing(v)) }) }
	static var becomeFirstResponder: BindingName<Signal<()>, Binding> { return BindingName<Signal<()>, Binding>({ v in .viewBinding(View.Binding.becomeFirstResponder(v)) }) }
}

protocol ViewBinding: BaseBinding {
	static func viewBinding(_ binding: View.Binding) -> Self
}
extension ViewBinding {
	static func baseBinderBinding(_ binding: BaseBinder.Binding) -> Self {
		return Self.viewBinding(.inheritedBinding(binding))
	}
}


// MARK: ### CwlTextField.swift ###

class TextField: ConstructingBinder, TextFieldInstance {
	typealias Instance = UITextField
	typealias Inherited = Control
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var textFieldInstance: Instance { return instance() }
	
	enum Binding: TextFieldBinding {
		typealias Binder = TextField
		static func textFieldBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(StaticValue<TextInputTraits>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case text(DynamicValue<String>)
		case attributedText(DynamicValue<NSAttributedString?>)
		case placeholder(DynamicValue<String?>)
		case attributedPlaceholder(DynamicValue<NSAttributedString?>)
		case defaultTextAttributes(DynamicValue<[String: Any]>)
		case font(DynamicValue<UIFont?>)
		case textColor(DynamicValue<UIColor?>)
		case textAlignment(DynamicValue<NSTextAlignment>)
		case typingAttributes(DynamicValue<[String: Any]?>)
		case adjustsFontSizeToFitWidth(DynamicValue<Bool>)
		case minimumFontSize(DynamicValue<CGFloat>)
		case clearsOnBeginEditing(DynamicValue<Bool>)
		case clearsOnInsertion(DynamicValue<Bool>)
		case allowsEditingTextAttributes(DynamicValue<Bool>)
		case borderStyle(DynamicValue<UITextBorderStyle>)
		case background(DynamicValue<UIImage?>)
		case disabledBackground(DynamicValue<UIImage?>)
		case clearButtonMode(DynamicValue<UITextFieldViewMode>)
		case leftView(DynamicValue<ViewInstance?>)
		case leftViewMode(DynamicValue<UITextFieldViewMode>)
		case rightView(DynamicValue<ViewInstance?>)
		case rightViewMode(DynamicValue<UITextFieldViewMode>)
		case inputView(DynamicValue<ViewInstance?>)
		case inputAccessoryView(DynamicValue<ViewInstance?>)
		
		//	2. Signal bindings are performed on the object after construction.
		case resignFirstResponder(Signal<()>)
		
		//	3. Action bindings are triggered by the object after construction.
		case didBeginEditing(SignalInput<()>)
		case didChange(SignalInput<TextFieldContents>)
		case didEndEditing(SignalInput<TextFieldContents>)
		@available(iOS 10.0, *)
		case didEndEditingWithReason(SignalInput<(TextFieldContents, UITextFieldDidEndEditingReason)>)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBeginEditing((_ textField: UITextField) -> Bool)
		case shouldEndEditing((_ textField: UITextField) -> Bool)
		case shouldChangeCharacters((_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool)
		case shouldClear((_ textField: UITextField) -> Bool)
		case shouldReturn((_ textField: UITextField) -> Bool)
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = TextField
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .didEndEditingWithReason(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextFieldDelegate.textFieldDidEndEditing(_:reason:))
					delegate().addSelector(s).didEndEditingWithReason = x
				}
			case .shouldBeginEditing(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .shouldChangeCharacters(let x):
				let s = #selector(UITextFieldDelegate.textField(_:shouldChangeCharactersIn:replacementString:))
				delegate().addSelector(s).shouldChangeCharacters = x
			case .shouldClear(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldClear(_:))
				delegate().addSelector(s).shouldClear = x
			case .shouldReturn(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldReturn(_:))
				delegate().addSelector(s).shouldReturn = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .textInputTraits(let x):
				return ArrayOfCancellables(x.value.bindings.lazy.flatMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .placeholder(let x): return x.apply(instance, storage) { i, s, v in i.placeholder = v }
			case .attributedPlaceholder(let x): return x.apply(instance, storage) { i, s, v in i.attributedPlaceholder = v }
			case .defaultTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.defaultTextAttributes = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .typingAttributes(let x): return x.apply(instance, storage) { i, s, v in i.typingAttributes = v }
			case .adjustsFontSizeToFitWidth(let x): return x.apply(instance, storage) { i, s, v in i.adjustsFontSizeToFitWidth = v }
			case .minimumFontSize(let x): return x.apply(instance, storage) { i, s, v in i.minimumFontSize = v }
			case .clearsOnBeginEditing(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnBeginEditing = v }
			case .clearsOnInsertion(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnInsertion = v }
			case .allowsEditingTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.allowsEditingTextAttributes = v }
			case .borderStyle(let x): return x.apply(instance, storage) { i, s, v in i.borderStyle = v }
			case .background(let x): return x.apply(instance, storage) { i, s, v in i.background = v }
			case .disabledBackground(let x): return x.apply(instance, storage) { i, s, v in i.disabledBackground = v }
			case .clearButtonMode(let x): return x.apply(instance, storage) { i, s, v in i.clearButtonMode = v }
			case .leftView(let x): return x.apply(instance, storage) { i, s, v in i.leftView = v?.viewInstance }
			case .leftViewMode(let x): return x.apply(instance, storage) { i, s, v in i.leftViewMode = v }
			case .rightView(let x): return x.apply(instance, storage) { i, s, v in i.rightView = v?.viewInstance }
			case .rightViewMode(let x): return x.apply(instance, storage) { i, s, v in i.rightViewMode = v }
			case .inputView(let x): return x.apply(instance, storage) { i, s, v in i.inputView = v?.viewInstance }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v?.viewInstance }
			case .resignFirstResponder(let x): return x.apply(instance, storage) { i, s, v in i.resignFirstResponder() }
			case .didBeginEditing(let x):
				return Signal
					.notifications(name: NSNotification.Name.UITextFieldTextDidBeginEditing, object: instance)
					.map { n in return () }
					.cancellableBind(to: x)
			case .didEndEditing(let x):
				return Signal
					.notifications(name: NSNotification.Name.UITextFieldTextDidEndEditing, object: instance)
					.compactMap { n in (n.object as? UITextField).map { .contents($0) } }
					.cancellableBind(to: x)
			case .didChange(let x):
				return Signal
					.notifications(name: NSNotification.Name.UITextFieldTextDidChange, object: instance)
					.compactMap { n in (n.object as? UITextField).map { .contents($0) } }
					.cancellableBind(to: x)
			case .didEndEditingWithReason: return nil
			case .shouldBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .shouldChangeCharacters: return nil
			case .shouldClear: return nil
			case .shouldReturn: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	class Storage: Control.Storage, UITextFieldDelegate {}
	
	class Delegate: DynamicDelegate, UITextFieldDelegate {
		required override init() {
			super.init()
		}
		
		var shouldBeginEditing: ((_ textField: UITextField) -> Bool)?
		func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
			return shouldBeginEditing!(textField)
		}
		
		var shouldEndEditing: ((_ textField: UITextField) -> Bool)?
		func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
			return shouldEndEditing!(textField)
		}
		
		var shouldChangeCharacters: ((_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool)?
		func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
			return shouldChangeCharacters!(textField, range, string)
		}
		
		var shouldClear: ((_ textField: UITextField) -> Bool)?
		func textFieldShouldClear(_ textField: UITextField) -> Bool {
			return shouldClear!(textField)
		}
		
		var shouldReturn: ((_ textField: UITextField) -> Bool)?
		func textFieldShouldReturn(_ textField: UITextField) -> Bool {
			return shouldReturn!(textField)
		}
		
		var didEndEditingWithReason: Any?
		@available(iOS 10.0, *)
		func textFieldDidEndEditing(_ textField: UITextField, reason: UITextFieldDidEndEditingReason) {
			(didEndEditingWithReason as! SignalInput<(TextFieldContents, UITextFieldDidEndEditingReason)>).send(value: (.contents(textField), reason))
		}
	}
}

extension BindingName where Binding: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .textFieldBinding(TextField.Binding.$1(v)) }) }
	static var textInputTraits: BindingName<StaticValue<TextInputTraits>, Binding> { return BindingName<StaticValue<TextInputTraits>, Binding>({ v in .textFieldBinding(TextField.Binding.textInputTraits(v)) }) }
	static var text: BindingName<DynamicValue<String>, Binding> { return BindingName<DynamicValue<String>, Binding>({ v in .textFieldBinding(TextField.Binding.text(v)) }) }
	static var attributedText: BindingName<DynamicValue<NSAttributedString?>, Binding> { return BindingName<DynamicValue<NSAttributedString?>, Binding>({ v in .textFieldBinding(TextField.Binding.attributedText(v)) }) }
	static var placeholder: BindingName<DynamicValue<String?>, Binding> { return BindingName<DynamicValue<String?>, Binding>({ v in .textFieldBinding(TextField.Binding.placeholder(v)) }) }
	static var attributedPlaceholder: BindingName<DynamicValue<NSAttributedString?>, Binding> { return BindingName<DynamicValue<NSAttributedString?>, Binding>({ v in .textFieldBinding(TextField.Binding.attributedPlaceholder(v)) }) }
	static var defaultTextAttributes: BindingName<DynamicValue<[String: Any]>, Binding> { return BindingName<DynamicValue<[String: Any]>, Binding>({ v in .textFieldBinding(TextField.Binding.defaultTextAttributes(v)) }) }
	static var font: BindingName<DynamicValue<UIFont?>, Binding> { return BindingName<DynamicValue<UIFont?>, Binding>({ v in .textFieldBinding(TextField.Binding.font(v)) }) }
	static var textColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .textFieldBinding(TextField.Binding.textColor(v)) }) }
	static var textAlignment: BindingName<DynamicValue<NSTextAlignment>, Binding> { return BindingName<DynamicValue<NSTextAlignment>, Binding>({ v in .textFieldBinding(TextField.Binding.textAlignment(v)) }) }
	static var typingAttributes: BindingName<DynamicValue<[String: Any]?>, Binding> { return BindingName<DynamicValue<[String: Any]?>, Binding>({ v in .textFieldBinding(TextField.Binding.typingAttributes(v)) }) }
	static var adjustsFontSizeToFitWidth: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.adjustsFontSizeToFitWidth(v)) }) }
	static var minimumFontSize: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .textFieldBinding(TextField.Binding.minimumFontSize(v)) }) }
	static var clearsOnBeginEditing: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.clearsOnBeginEditing(v)) }) }
	static var clearsOnInsertion: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.clearsOnInsertion(v)) }) }
	static var allowsEditingTextAttributes: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.allowsEditingTextAttributes(v)) }) }
	static var borderStyle: BindingName<DynamicValue<UITextBorderStyle>, Binding> { return BindingName<DynamicValue<UITextBorderStyle>, Binding>({ v in .textFieldBinding(TextField.Binding.borderStyle(v)) }) }
	static var background: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .textFieldBinding(TextField.Binding.background(v)) }) }
	static var disabledBackground: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .textFieldBinding(TextField.Binding.disabledBackground(v)) }) }
	static var clearButtonMode: BindingName<DynamicValue<UITextFieldViewMode>, Binding> { return BindingName<DynamicValue<UITextFieldViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.clearButtonMode(v)) }) }
	static var leftView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .textFieldBinding(TextField.Binding.leftView(v)) }) }
	static var leftViewMode: BindingName<DynamicValue<UITextFieldViewMode>, Binding> { return BindingName<DynamicValue<UITextFieldViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.leftViewMode(v)) }) }
	static var rightView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .textFieldBinding(TextField.Binding.rightView(v)) }) }
	static var rightViewMode: BindingName<DynamicValue<UITextFieldViewMode>, Binding> { return BindingName<DynamicValue<UITextFieldViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.rightViewMode(v)) }) }
	static var inputView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .textFieldBinding(TextField.Binding.inputView(v)) }) }
	static var inputAccessoryView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .textFieldBinding(TextField.Binding.inputAccessoryView(v)) }) }
	static var resignFirstResponder: BindingName<Signal<()>, Binding> { return BindingName<Signal<()>, Binding>({ v in .textFieldBinding(TextField.Binding.resignFirstResponder(v)) }) }
	static var didBeginEditing: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .textFieldBinding(TextField.Binding.didBeginEditing(v)) }) }
	static var didChange: BindingName<SignalInput<TextFieldContents>, Binding> { return BindingName<SignalInput<TextFieldContents>, Binding>({ v in .textFieldBinding(TextField.Binding.didChange(v)) }) }
	static var didEndEditing: BindingName<SignalInput<TextFieldContents>, Binding> { return BindingName<SignalInput<TextFieldContents>, Binding>({ v in .textFieldBinding(TextField.Binding.didEndEditing(v)) }) }
	@available(iOS 10.0, *)
	static var didEndEditingWithReason: BindingName<SignalInput<(TextFieldContents, UITextFieldDidEndEditingReason)>, Binding> { return BindingName<SignalInput<(TextFieldContents, UITextFieldDidEndEditingReason)>, Binding>({ v in .textFieldBinding(TextField.Binding.didEndEditingWithReason(v)) }) }
	static var shouldBeginEditing: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldBeginEditing(v)) }) }
	static var shouldEndEditing: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldEndEditing(v)) }) }
	static var shouldChangeCharacters: BindingName<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool, Binding> { return BindingName<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldChangeCharacters(v)) }) }
	static var shouldClear: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldClear(v)) }) }
	static var shouldReturn: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldReturn(v)) }) }
}

protocol TextFieldInstance: ControlInstance {
	var textFieldInstance: TextField.Instance { get }
}
extension TextFieldInstance {
	var controlInstance: Control.Instance { return textFieldInstance }
}
extension TextField.Instance: TextFieldInstance {
	var textFieldInstance: TextField.Instance { return self }
}

protocol TextFieldBinding: ControlBinding {
	static func textFieldBinding(_ binding: TextField.Binding) -> Self
}
extension TextFieldBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return Self.textFieldBinding(.inheritedBinding(binding))
	}
}

func textFieldResignOnReturn(condition: @escaping (TextFieldContents) -> Bool = { _ in return true }) -> (UITextField) -> Bool {
	return { tf in
		if condition(TextFieldContents.contents(tf)) {
			tf.resignFirstResponder()
			return false
		}
		return true
	}
}

enum TextFieldContents {
	case plain(String)
	case attributed(NSAttributedString)
	
	var text: String {
		switch self {
		case .plain(let s): return s
		case .attributed(let s): return s.string
		}
	}
	
	static func contents(_ textField: UITextField) -> TextFieldContents {
		return textField.attributedText.map { TextFieldContents.attributed($0) } ?? textField.text.map { TextFieldContents.plain($0) } ?? .plain("")
	}
}


// MARK: ### CwlButton.swift ###

class Button: ConstructingBinder, ButtonInstance {
	typealias Instance = UIButton
	typealias Inherited = Control
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var buttonInstance: Instance { return instance() }
	
	enum Binding: ButtonBinding {
		typealias Binder = Button
		static func buttonBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case type(StaticValue<UIButtonType>)
		case titleLabel(StaticValue<Label>)
		case imageView(StaticValue<ImageView>)
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case adjustsImageWhenHighlighted(DynamicValue<Bool>)
		case adjustsImageWhenDisabled(DynamicValue<Bool>)
		case showsTouchWhenHighlighted(DynamicValue<Bool>)
		case contentEdgeInsets(DynamicValue<UIEdgeInsets>)
		case titleEdgeInsets(DynamicValue<UIEdgeInsets>)
		case imageEdgeInsets(DynamicValue<UIEdgeInsets>)
		
		case title(DynamicValue<ScopedValues<UIControlState, String?>>)
		case titleColor(DynamicValue<ScopedValues<UIControlState, UIColor?>>)
		case titleShadowColor(DynamicValue<ScopedValues<UIControlState, UIColor?>>)
		case attributedTitle(DynamicValue<ScopedValues<UIControlState, NSAttributedString?>>)
		case backgroundImage(DynamicValue<ScopedValues<UIControlState, UIImage?>>)
		case image(DynamicValue<ScopedValues<UIControlState, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
	  // 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = Button
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance {
			return subclass.init(type: type)
		}
		
		var type: UIButtonType = .roundedRect
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .type(let x): type = x.value
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .titleLabel(let x):
				if let tl = instance.titleLabel {
					x.value.applyBindings(to: tl)
				}
				return nil
			case .imageView(let x):
				if let iv = instance.imageView {
					x.value.applyBindings(to: iv)
				}
				return nil
			case .type: return nil
			case .title(let x):
				var previous: ScopedValues<UIControlState, String?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitle(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitle(c.1, for: c.0)
					}
				}
			case .titleColor(let x):
				var previous: ScopedValues<UIControlState, UIColor?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleColor(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleColor(c.1, for: c.0)
					}
				}
			case .titleShadowColor(let x):
				var previous: ScopedValues<UIControlState, UIColor?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleShadowColor(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleShadowColor(c.1, for: c.0)
					}
				}
			case .attributedTitle(let x):
				var previous: ScopedValues<UIControlState, NSAttributedString?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setAttributedTitle(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setAttributedTitle(c.1, for: c.0)
					}
				}
			case .backgroundImage(let x):
				var previous: ScopedValues<UIControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackgroundImage(c.1, for: c.0)
					}
				}
			case .image(let x):
				var previous: ScopedValues<UIControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setImage(c.1, for: c.0)
					}
				}
			case .adjustsImageWhenHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.adjustsImageWhenHighlighted = v }
			case .adjustsImageWhenDisabled(let x): return x.apply(instance, storage) { i, s, v in i.adjustsImageWhenDisabled = v }
			case .showsTouchWhenHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.showsTouchWhenHighlighted = v }
			case .contentEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.contentEdgeInsets = v }
			case .titleEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.titleEdgeInsets = v }
			case .imageEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.imageEdgeInsets = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = Control.Storage
}

extension BindingName where Binding: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .buttonBinding(Button.Binding.$1(v)) }) }
	static var type: BindingName<StaticValue<UIButtonType>, Binding> { return BindingName<StaticValue<UIButtonType>, Binding>({ v in .buttonBinding(Button.Binding.type(v)) }) }
	static var titleLabel: BindingName<StaticValue<Label>, Binding> { return BindingName<StaticValue<Label>, Binding>({ v in .buttonBinding(Button.Binding.titleLabel(v)) }) }
	static var imageView: BindingName<StaticValue<ImageView>, Binding> { return BindingName<StaticValue<ImageView>, Binding>({ v in .buttonBinding(Button.Binding.imageView(v)) }) }
	static var adjustsImageWhenHighlighted: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .buttonBinding(Button.Binding.adjustsImageWhenHighlighted(v)) }) }
	static var adjustsImageWhenDisabled: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .buttonBinding(Button.Binding.adjustsImageWhenDisabled(v)) }) }
	static var showsTouchWhenHighlighted: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .buttonBinding(Button.Binding.showsTouchWhenHighlighted(v)) }) }
	static var contentEdgeInsets: BindingName<DynamicValue<UIEdgeInsets>, Binding> { return BindingName<DynamicValue<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.contentEdgeInsets(v)) }) }
	static var titleEdgeInsets: BindingName<DynamicValue<UIEdgeInsets>, Binding> { return BindingName<DynamicValue<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.titleEdgeInsets(v)) }) }
	static var imageEdgeInsets: BindingName<DynamicValue<UIEdgeInsets>, Binding> { return BindingName<DynamicValue<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.imageEdgeInsets(v)) }) }
	static var title: BindingName<DynamicValue<ScopedValues<UIControlState, String?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, String?>>, Binding>({ v in .buttonBinding(Button.Binding.title(v)) }) }
	static var titleColor: BindingName<DynamicValue<ScopedValues<UIControlState, UIColor?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIColor?>>, Binding>({ v in .buttonBinding(Button.Binding.titleColor(v)) }) }
	static var titleShadowColor: BindingName<DynamicValue<ScopedValues<UIControlState, UIColor?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIColor?>>, Binding>({ v in .buttonBinding(Button.Binding.titleShadowColor(v)) }) }
	static var attributedTitle: BindingName<DynamicValue<ScopedValues<UIControlState, NSAttributedString?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, NSAttributedString?>>, Binding>({ v in .buttonBinding(Button.Binding.attributedTitle(v)) }) }
	static var backgroundImage: BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding>({ v in .buttonBinding(Button.Binding.backgroundImage(v)) }) }
	static var image: BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding>({ v in .buttonBinding(Button.Binding.image(v)) }) }
}

protocol ButtonInstance: ControlInstance {
	var buttonInstance: Button.Instance { get }
}
extension ButtonInstance {
	var controlInstance: Control.Instance { return buttonInstance }
}
extension Button.Instance: ButtonInstance {
	var buttonInstance: Button.Instance { return self }
}

protocol ButtonBinding: ControlBinding {
	static func buttonBinding(_ binding: Button.Binding) -> Self
}

extension ButtonBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return Self.buttonBinding(.inheritedBinding(binding))
	}
}

